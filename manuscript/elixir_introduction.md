# Введение в Elixir

В предыдущей главе мы создали бэкенд-платформу на Phoenix. По умолчанию приложения Phoenix содержат много кода Elixir. Но если мы только начинаем работать с языком Elixir, нам, вероятно, стоит взглянуть на несколько простых примеров Elixir и лучше понять, как работать с инструментами.

## Создание Elixir-проекта

Давайте создадим небольшой временный проект. Мы будем использовать тот же инструмент `mix`, который использовали в предыдущей главе, когда создавали наше приложение Phoenix, но на этот раз мы просто создаем маленький проект Elixir и назовём его `temporary`. Запустите следующую команду в терминале:

```shell
$ mix new temporary
```

Инструмент `mix` — это простой инструмент для сборки, поставляемый вместе с Elixir. Вот как должен выглядеть вывод при создании проекта:

```shell
$ mix new temporary
* creating README.md
* creating .formatter.exs
* creating .gitignore
* creating mix.exs
* creating config
* creating config/config.exs
* creating lib
* creating lib/temporary.ex
* creating test
* creating test/test_helper.exs
* creating test/temporary_test.exs

Your Mix project was created successfully.
You can use "mix" to compile it, test it, and more:

    cd temporary
    mix test

Run "mix help" for more commands.
```

Давайте перейдем в директорию нового проекта и посмотрим на созданные файлы:

```shell
$ cd temporary
```

Первое, что вы можете заметить — проект Elixir и проект на Phoenix имеют много общего. Структура директорий похожа:

![Структура директорий Elixir](images/elixir_introduction/elixir_folder_structure.png)

Созданный в предыдущей главе проект `platform`, содержит больше файлов и директорий, но важно отметить, что это все еще проект Elixir, такой же, как `temporary`, который мы только что создали. Директория `config` содержит параметры конфигурации, папка `lib` — это там, где мы будем писать большую часть нашего кода на Elixir, а в директории `test` находятся тесты, которые позволяют нам удостовериться в том, что приложение работает так, как предполагалось.

## Тестирование в Elixir

Вне зависимости от того, с какими языками программирования вы работали в прошлом, у вас, возможно, есть большой опыт написания тестов.

Если ранее вы не писали тесты, основная идея является то, что тесты дают возможность почувствовать уверенность в том, что код действительно работает так, как ожидалось. Мы пишем наши предположения (или «утверждения»), которые дают нам быстрый способ проверить, работает ли должным образом написанный нами код (и не нарушает ли он работу другого кода). Позже мы углубимся в тестирование с нашим приложением Phoenix, но сейчас давайте просто попробуем тесты в действии.

Запустите команду `mix test` внутри директории `temporary`:

```shell
$ mix test
```

Вывод должен быть примерно таким:

```shell
$ mix test
Compiling 1 file (.ex)
Generated temporary app
..

Finished in 0.03 seconds
1 doctest, 1 test, 0 failures

Randomized with seed 670956
```

## Компиляция Elixir

В этом разделе мы начнем знакомиться с некоторыми ключевыми особенностями Elixir. Во-первых, мы увидим, что Elixir — это _компилируемый_ язык. Когда мы в первый раз запускаем наш код после внесения изменений, Elixir должен скомпилировать его в байт-код Erlang. Это может быть очень полезно, потому что означает, что мы скорее будем отлавливать ошибки, чем отлаживать приложение время его использования.

На самом деле, если мы снова запустим команду `mix test`, то увидим, что Elixir не нужно перекомпилировать код, потому что мы не внесли никаких изменений (обратите внимание, что строка о компиляции файлов теперь отсутствует):

```shell
$ mix test
..

Finished in 0.03 seconds
1 doctest, 1 test, 0 failures

Randomized with seed 114557
```

## Модули и функции Elixir

Код Elixir, который мы напишем в этом проекте, находится в файле `lib/temporary.ex`. Файлы с расширением `.ex` — это файлы Elixir, которые будут скомпилированы и запущены (вы также заметите, что у нас есть файлы с расширением `.exs`, представляющие собой скрипты Elixir).

Внутри файла `lib/temporary.ex` мы видим базовую структуру для _всех_ программ Elixir, которые мы будем писать.

```elixir
defmodule Temporary do
  @moduledoc """
  Documentation for Temporary.
  """

  @doc """
  Hello world.

  ## Examples

      iex> Temporary.hello()
      :world

  """
  def hello do
    :world
  end
end
```

Начнем с **модуля**, который инкапсулирует соответствующий код:

```elixir
defmodule Temporary do
  # ...
end
```

Если пока игнорировать комментарии с документацией, мы увидим одну **функцию**:

```elixir
def hello do
  :world
end
```

Внутри этой функции есть **возвращаемое значение**:

```elixir
:world
```

Давайте начнем вносить некоторые изменения. Переименуйте функцию `hello` на `add`. Передадим два параметра (`x` и `y`) и вернем сложение этих двух значений, используя выражение `x + y` внутри функции:

```elixir
def add(x, y) do
  x + y
end
```

## Функции, тесты и документация

Приведенный выше пример, конечно, простой, но он хорош потому что мы теперь знаем, как создать функцию. Но каким образом мы будем их использовать?

Как правило, мы используем синтаксис вида `Module.function(arguments)` для вызова объявленных функций. Если мы посмотрим на изначальную документацию для нашей функции `hello`, то увидим пример использования:

```elixir
defmodule Temporary do
  @moduledoc """
  Documentation for Temporary.
  """

  @doc """
  Hello world.

  ## Examples

      iex> Temporary.hello()
      :world

  """
  def add(x, y) do
    x + y
  end
end
```

Часть комментария с примером использования указывает на то, что если мы выполним строчку кода `Temporary.hello()`, то она вернет `:world`. Вот тут начинается самое интересное, поэтому давайте снова запустим `mix test`:

```shell
$ mix test
```

Поскольку больше нет функции `hello`, неудивительно, что тесты не прошли. На самом деле у нас _два_ неудачных теста. Один из них взят из тестового файла в директории `test`, в то время как другой в действительности взялся из примера использования в документации (который называется **doctest**).

```shell
$ mix test
Compiling 1 file (.ex)

  1) test greets the world (TemporaryTest)
     test/temporary_test.exs:5
     ** (UndefinedFunctionError) function Temporary.hello/0 is undefined or private
     code: assert Temporary.hello() == :world
     stacktrace:
       (temporary) Temporary.hello()
       test/temporary_test.exs:6: (test)

  2) doctest Temporary.add/2 (1) (TemporaryTest)
     test/temporary_test.exs:3
     Doctest failed: got UndefinedFunctionError with message "function Temporary.hello/0 is undefined or private"
     code: Temporary.hello()
     stacktrace:
       (temporary) Temporary.hello()
       (for doctest at) lib/temporary.ex:11: (test)

Finished in 0.04 seconds
1 doctest, 1 test, 2 failures

Randomized with seed 520513
```

Давайте обновим документацию, чтобы она отражала реальный пример использования новой функции `add`:

```elixir
defmodule Temporary do
  @moduledoc """
  Documentation for Temporary.
  """

  @doc """
  Add two numbers together.

  ## Examples

      iex> Temporary.add(1, 1)
      2

  """
  def add(x, y) do
    x + y
  end
end
```

Можно снова запустить тесты, и на этот раз доктест в `lib/temporary.ex` должен пройти:

```shell
$ mix test
➜  temporary mix test
Compiling 1 file (.ex)
.

  1) test greets the world (TemporaryTest)
     test/temporary_test.exs:5
     ** (UndefinedFunctionError) function Temporary.hello/0 is undefined or private
     code: assert Temporary.hello() == :world
     stacktrace:
       (temporary) Temporary.hello()
       test/temporary_test.exs:6: (test)

Finished in 0.03 seconds
1 doctest, 1 test, 1 failure

Randomized with seed 682227
```

Доктесты — потрясающая _возможность_ Elixir, позволяющая нам одновременно _и_ документировать, _и_ проверять работу функции! Это вдохновляет нас писать и поддерживать документацию, а также придает уверенность в том, что наш код действительно делает то, что мы задумали.

## Написание тестов

Давайте напишем несколько тестов, чтобы убедиться, что наша функция добавления работает так, как должна. Откройте файл `test/temporary_test.ex` и добавьте следующий код:

```elixir
defmodule TemporaryTest do
  use ExUnit.Case
  doctest Temporary

  test "the add function takes two integers and adds them together" do
    result = Temporary.add(1, 1)
    assert result == 2
  end

  test "the add function takes two floats and adds them together" do
    result = Temporary.add(1.5, 1.5)
    assert result == 3.0
  end

  test "the add function returns a number" do
    result = Temporary.add(1.5, 3.5)
    result_is_a_number = is_number(result)
    assert result_is_a_number
  end
end
```

Рассмотрите содержимое файла `test/temporary_test.exs` и обратите внимание, что тестовый код по-прежнему имеет тот же общий формат, который мы использовали в `lib/temporary.ex`, где у нас есть определение модуля в самом вверху, содержащий остальную часть кода. Мы также видим, что используем стандартную библиотеку [`ExUnit`](https://hexdocs.pm/ex_unit/ExUnit.html) для написания тестов. Кроме этого, есть строчка `doctest Temporary`, чтобы тесты знали, как выполнять примеры, написанные в документации.

В трех тестовых сценариев (`test`) показаны простые примеры того, как мы можем вызывать функцию с некоторыми примерами чисел и проверять правильность результата. Например, передача `1` и `1` в качестве аргументов функции `add` должна вернуть результат `2`. Есть и другие [утверждения](https://hexdocs.pm/ex_unit/ExUnit.Assertions.html), предоставляемые `ExUnit`, но пока мы остановимся на `assert` с целью проверить на значение `true` в наших тестах.

Теперь, если мы снова запустим тесты, то увидим, что все три из этих тестовых вариантов проходят (включая и доктест):

```shell
$ mix test
....

Finished in 0.03 seconds
1 doctest, 3 tests, 0 failures

Randomized with seed 867380
```

## IEx

Как бы нам запустить код в интерактивной среде? Тесты хорошо подходят для проверки значений, но что, если что-то не работает так, как мы ожидали? Давайте запустим следующую команду из директории проекта `temporary`:

```shell
$ iex -S mix
```

Эта команда позволяет запускать код Elixir в интерактивной среде и просматривать результаты (вы также можете использовать просто `iex` из командной строки для начала, но использование `iex -S mix` предпочтительнее, поскольку тогда нам не нужно вручную импортировать модули, с которыми мы хотим работать).

Вот пример, где мы в основном повторяем наш первый тестовый случай, который вызывает функцию `add`, определенную в модуле `Temporary`, чтобы увидеть такой результат:

```elixir
$ iex -S mix
Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)
iex(1)> Temporary.add(1, 1)
2
```

Мы также можем попробовать второй тестовый пример:

```elixir
iex(2)> Temporary.add(1.5, 1.5)
3.0
```

В тестах все работает как ожидается, а теперь мы еще узнали про интерактивный способ проверки кода. Не стесняйтесь писать какой-нибудь Elixir-кода в интерактивной среде, а затем дважды нажмите сочетание клавиш `Control + C`, когда захотите выйти.

## Оператор конвейера

В нашем третьем тесте используется распространенная модель программирования — мы разбиваем код на маленькие фрагменты и присваиваем значения переменным. Такой подход имеет большое преимущество, связанный с возможностью именования очевидными способами, но в Elixir есть альтернативный подход, помогающий нам пересмотреть метод написания кода.

Идея «оператора конвейера» (`|>`) заключается в том, что он стимулирует нас думать о функциях с точки зрения преобразования данных. Вместо использования переменных, мы берем начальное значение, передаем его через небольшое количество функций и в конце возвращаем результат. Давайте еще раз посмотрим на третий сценарий:

```elixir
test "the add function returns a number" do
  result = Temporary.add(1.5, 3.5)
  result_is_a_number = is_number(result)
  assert result_is_a_number
end
```

Этот пример намеренно написан, используя дополнительные переменные, которые не особенно нужны. Давайте вместо этого воспользуемся синтаксисом оператора конвейера, с учетом того, что код все еще делает то же самое:

```elixir
test "the add function returns a number" do
  Temporary.add(1.5, 3.5)
  |> is_number
  |> assert
end
```

Вау! И что здесь происходит? Вместо того, чтобы использовать переменные, мы сначала вычисляем результат, а затем используем `|>` для передачи его как аргумент следующей функции.

Данный оператор также позволяет получать данные и передавать их другим функциям. Например, давайте проверим, какое значение передается `assert` в конце:

```elixir
test "the add function returns a number" do
  Temporary.add(1.5, 3.5)
  |> is_number
  |> IO.inspect()
  |> assert
end
```

Можно выполнить `mix test` из командной строки, чтобы увидеть результаты:

```shell
$ mix test
true
....

Finished in 0.03 seconds
1 doctest, 3 tests, 0 failures

Randomized with seed 312071
```

Это объясняет, почему тест проходит, поскольку `true` передается в функцию `assert`.

## Больше конвейерной обработки

Это простые примеры, потому что каждая из этих функций по одному аргументу. Но что, если мы хотим передать функцию, принимающая несколько аргументов? При использовании оператора конвейера в Elixir, он передает значение в качестве _первого_ аргумента в следующую функцию.

Другими словами, мы могли бы изменить код теста с целью передать первое значение, как показано ниже:

```elixir
test "the add function returns a number" do
  1.5
  |> Temporary.add(3.5)
  |> is_number
  |> IO.inspect()
  |> assert
end
```

Обновленный код теста демонстрирует, что мы можем передать значение `1.5` в функцию `Temporary.add`, и данное значение будет использоваться в качестве _первого_ аргумента, когда как значение `3.5` будет передано _вторым_ аргументом функции `Temporary.add`.

Прежде чем мы продолжим, давайте вернемся к изначальному примеру оператора конвейера, поскольку это более чистый код. Но приведенные выше примеры являются важной демонстрацией того, как мы можем использовать оператор конвейера.

```elixir
test "the add function returns a number" do
  Temporary.add(1.5, 3.5)
  |> is_number
  |> assert
end
```

## Арность функций

В этой книге мы обращались к таким функциям (например, функция `add`), как просто `add`. Но функции в Elixir часто дают обозначают в соответствии с их «арностью».

Арность функции — это количество аргументов, которые она принимает. В вышеприведенных примерах функция `add` принимает два аргумента, поэтому она будет именоваться в тексте `add/2`. Функция `is_number` принимает только один аргумент, поэтому мы бы ее именовали как `is_number/1`.

В остальной части книги с целью соблюдения единообразия, мы будем ссылаться на функции, учитывая их арность, поскольку она имеет особое значение в языке Elixir. Кстати, мы можем определить несколько функций с одним и тем же именем, но с различным поведением в зависимости от количества переданных аргументов. Поначалу это может показаться сложной концепцией, однако вскоре мы увидим несколько примеров, которые помогут прояснить эту идею.

## Сокращенный синтаксис определения функции

На данный момент мы, вероятно, очень хотим вернуться в Phoenix и разрабатывать наше приложение. Но есть еще пара тем из Elixir, которые помогут нам в изучении код на Phoenix. Не зная концепций, лежащих в основе Elixir, в действительности сложно понять, что происходит в Phoenix.

Функции, которые мы видели до сих пор, имели следующий формат:

```elixir
def function_name(arguments) do
  # ...
end
```

Когда мы имеем дело с небольшими простыми функциями, такими как `add/2`, возможно сделать код более кратким и читаемым, если использовать сокращенный синтаксис объявления функции:

```elixir
def function_name(arguments), do: ...
```

Обратите внимание, что есть дополнительные символы `,` и `:`, использование которых позволит нам удалить ключевое слово `end` и написать все тело функции в одну строку.

Ниже функция `add/2`, написанная в виде одной строки. Вы можете обновить пример в файле `lib/temporary.ex`, а затем снова запустить команду `mix test`, чтобы убедиться, что он все еще работает.

```elixir
def add(x, y), do: x + y
```

Нет строгих правил относительно того, когда нужно использовать сокращенный синтаксис объявления функции. С одной стороны, хорошая практика — разделять программы на небольшие функции, которые становятся легче для понимания, а это значит, что многие функции хорошо вписываются в одну строку. Однако вам необязательно стремится писать многострочные функции в одну строку. В данный момент мы знакомимся с этой концепцией, потому что функцию `add/2` будет проще визуально представить и объяснять в следующем разделе при использовании сокращенного синтаксиса определения функции.

## Сопоставление с образцом

Причина применения сокращенного синтаксиса определения функции — это более очевидный способ узнать одну из самых мощных возможностей Elixir в действии: сопоставление с образцом.

Поначалу метод сопоставления с образцом может быть трудным для понимания, поэтому будьте нежны с самим собой, если потребуется какое-то время для понимания. Это одна из тех тем, которую нужно увидеть и испытать пару раз, прежде чем ее поймешь.

Elixir позволяет нам создавать несколько «условий» функций. Это означает, что можно создать новое условие для функции `add/2`, и тогда Elixir будет использовать сопоставление с образцом для определения, какое из условий нужно использовать при вызове функции. Это звучит странно, поэтому давайте рассмотрим пример.

Когда мы добавляем `0` к числу, фактически результатом является просто само число (это еще известно как _тождественное свойство сложения_). Так что выражение `0 + 1` должно вернуть результат `1`. При использовании функции `add/2`, такой случай использования будет таким:

```elixir
iex> Temporary.add(0, 1)
1
```

Это означает, что всякий раз, когда мы передаем `0` в качестве аргумента функции, нам не нужно выполнять каких-либо операций сложения. Можно добавить новое условие для нашей функции `add/2`, которая обрабатывает случаи, когда первый аргумент равен `0`:

```elixir
def add(0, y), do: y
def add(x, y), do: x + y
```

В первой строчке мы просто игнорируем аргумент `0` и возвращаем значение `y` как результат. Далее можно сделать аналогичное, когда второй аргумент равен `0`:

```elixir
def add(0, y), do: y
def add(x, 0), do: x
def add(x, y), do: x + y
```

Во второй строчке мы снова игнорируем аргумент `0` и просто возвращаем значение `x`. Далее, мы можем даже добавить еще одно условие, которое «соответствует», когда оба аргумента представлены значением `0`:

```elixir
def add(0, 0), do: 0
def add(0, y), do: y
def add(x, 0), do: x
def add(x, y), do: x + y
```

И, наконец, полная версия примера с несколькими дополнительными доктестами для проверки того, что все работает как ожидается:

```elixir
defmodule Temporary do
  @moduledoc """
  Documentation for Temporary.
  """

  @doc """
  Add two numbers together.

  ## Examples

      iex> Temporary.add(0, 0)
      0

      iex> Temporary.add(0, 1)
      1

      iex> Temporary.add(1, 0)
      1

      iex> Temporary.add(1, 1)
      2
  """
  def add(0, 0), do: 0
  def add(0, y), do: y
  def add(x, 0), do: x
  def add(x, y), do: x + y
end
```

## Ограничители

Наконец, Elixir позволяет нам добавлять «операторы-ограничители» в функциях, чтобы убедиться, что они работают с правильными значениями.

Функция `add/2` предназначена только для работы с числами. Они могут быть целыми числами или числами с плавающей запятой, но мы не хотим добавлять строки вместе (конкатенация строк фактически потребует использования оператора `<>`).

Мы можем использовать ключевое слово `when` вместе с функцией `is_number/1`, которую мы видели ранее, для того, чтобы указать, что данная функция работает только с числовыми значениями.

```elixir
def add(0, 0), do: 0
def add(0, y) when is_number(y), do: y
def add(x, 0) when is_number(x), do: x
def add(x, y) when is_number(x) and is_number(y), do: x + y
```

Такие функции, как `is_number/1`, могут быть очень полезны для проверки типов значений, с которыми мы работаем. Один полезный совет — найти похожие функции, доступные с помощью `iex`. Внутри `iex` введите `is_`, а затем нажмите клавишу TAB и она отобразит различные доступные проверки:

```elixir
$ iex
iex(1)> is_
# Press TAB key after is_
is_atom/1         is_binary/1       is_bitstring/1    is_boolean/1
is_float/1        is_function/1     is_function/2     is_integer/1
is_list/1         is_map/1          is_nil/1          is_number/1
is_pid/1          is_port/1         is_reference/1    is_tuple/1
```

## Резюме

Эта глава предназначена, чтобы дать краткое введение в концепции Elixir. Они будут неоценимы, когда мы начнем создавать приложения с помощью Phoenix, потому что мы увидим, что код Phoenix 
— это на самом деле просто код на Elixir. Без некоторого опыта в Elixir иногда бывает трудно понять, что же происходит.

Текущая глава не задумывалась как исчерпывающее введение в Elixir. Есть еще много концепций, а также несколько книг, которые дают полное введение в язык. В этой книге мы продолжим двигаться дальше, потому что наша цель — создать реальное практическое приложение. Однако обратите внимание на бесплатные ресурсы ниже, если вы хотите получить немного больше опыта с Elixir, перед тем, как продолжить:

- [Руководство по началу работы с Elixir (на англ.)](http://elixir-lang.org/getting-started/introduction.html)
- [Elixir School](https://elixirschool.com/ru/lessons/basics/basics)

Можете спокойно удалить временный проект `temporary`, а в следующей главе мы продолжим работу по созданию приложения для игровой платформы.
