# Приступаем к работе

Вместо того, чтобы просто _читать_ про Elixir и Elm, давайте погрузимся и _познакомимся_ с тем, что могут предложить эти языки. В данной главе мы пропустим подробные объяснения и теорию в пользу быстрого создания заготовки для нашего проекта. Мы сосредоточимся на запуске необходимых команд в терминале и написании кода, который нам понадобится для начала разработки приложения.

Позже в книге мы расскажем больше об основах Elixir, но сейчас давайте обратим внимание на то, чтобы следовать инструкциям, указанным в книге, а также бегло ознакомимся с тем, как настроить и запустить приложение.

## Установка

Если вы еще не настроили собственную среду для разработки на Elixir, Phoenix и PostgreSQL, **ознакомьтесь с [Приложением](#appendix) в конце книги для получения соответствующих инструкций по быстрой установке**.

Также обратите внимание, что мы работаем с _последней_ версией Phoenix в этой книге. Убедитесь, что у вас установлен **Phoenix 1.4**, иначе команды и файлы будут выглядеть по-разному во время работы с материалом.

## Создание платформы

Первый шаг, который нам нужно сделать, — создать заготовку для нашего приложения. Для этого откроем терминал и запустим следующую команду:

```shell
$ mix phx.new platform
```

Команда задаст следующий вопрос:

> Fetch and install dependencies?

Введите букву `Y` и отобразится следующий вывод (обратите внимание, что некоторые строчки создания файлов были обрезаны для удобства чтения):

```shell
$ mix phx.new platform
* creating platform/mix.exs
* creating platform/README.md
* creating platform/assets/...
* creating platform/config/...
* creating platform/lib/platform/...
* creating platform/lib/platform_web/...
* creating platform/priv/...
* creating platform/test/...

Fetch and install dependencies? [Yn] Y
* running mix deps.get
* running mix deps.compile
* running cd assets && npm install && node node_modules/webpack/bin/webpack.js --mode development
```

У нас все готово! Зайдите в приложение путем его запуска:

    $ cd platform

Затем настройте базу данных в файле `config/dev.exs` и выполните команду ниже:

    $ mix ecto.create

Запустите приложение на Phoenix следующим образом:

    $ mix phx.server

Вы также можете запустить приложение внутри IEx (Interactive Elixir) вот так:

    $ iex -S mix phx.server

Phoenix отображает _много_ полезной информации. Во-первых, в выводе отображаются все сгенерированные файлы (не беспокойтесь, если на первый взгляд вывод кажется огромным; мы начнем только с нескольких этих файлов). Затем мы видим некоторую информацию о том, как настроить базу данных и запустить сервер.

## Настройка базы данных

Теперь как мы создали файлы для нашего приложения Phoenix, давайте перейдем к нужной директории:

```shell
$ cd platform
```

Мы можем настроить базу данных для проекта, если выполним следующую команду:

```shell
$ mix ecto.create
```

Если вы столкнетесь с проблемами при выполнении команд — это, вероятно, значит, что предстоит установить PostgreSQL или настроить поля `username` и `password`  в нижней части файла `config/dev.exs`. Вы также можете заглянуть в [Приложение](#appendix) в конце книги для получения дополнительной информации о PostgreSQL.

Поскольку мы впервые запускаем команду с нашим новым приложением, мы увидим, что для компиляции исходного кода потребуется некоторое время. Elixir работает на виртуальной машине Erlang и должен скомпилировать исходный код в байт-код, прежде чем мы сможем запустить наши программы. На первоначальном этапе нужно время для запуска, но последующие команды будут работать заметно быстрее.

Если создание базы данных прошло успешно, мы увидим следующее сообщение внизу:

```shell
$ mix ecto.create
Compiling files (.ex) ...
Generated platform app
The database for Platform.Repo has been created
```

Мы успешно создали приложение Phoenix, скомпилировали его и настроили базу данных.

## Запуск сервера

Посмотрим, как выглядит приложение в браузере. Чтобы запустить веб-сервер, выполните следующую команду:

```shell
$ mix phx.server
```

Команда выше запустит сервер, доступный по URL-адресу [`http://localhost:4000`](http://localhost:4000) из браузера, чтобы увидеть, как работает наше новое приложение. Вот как будет выглядеть вывод (игнорируя дополнительный вывод от Webpack):

```shell
$ mix phx.server
[info] Running PlatformWeb.Endpoint with cowboy using http://localhost:4000
```

![Начальная страница Phoenix по умолчанию](images/diving_in/phoenix_start.png)

На данном этапе вас может впечатлить то, что нам удалось создать и запустить так быстро полноценный бэкенд. Хотя, возможно, вы наблюдали подобные возможности у других фреймворках, и поэтому вы пока нисколько не удивлены текущими результатами. Мы собираемся начать разработку функционала приложения, но стоит задуматься на мгновение и оценить, сколько же у нас всякого, созданного всего лишь с помощью нескольких команд.

Не стесняйтесь посмотреть на определенные разделы замечательной документации, которые перечислены на начальной странице Phoenix по умолчанию. Прежде чем мы продолжим, давайте остановим веб-сервер Phoenix. Вернитесь в окно терминала, где запущен сервер, и _дважды_ нажмите `Control + C` на клавиатуре для остановки сервера. Это, как правило, самый простой способ выйти из  выполняющейся программы на Elixir, и вот как будет выглядеть вывод при завершении работы сервера:

```shell
$ mix phx.server
[info] Running Platform.Endpoint with cowboy using http://localhost:4000
[info] Compiled 6 files into 2 files, copied 3 in 2.1 sec
[info] GET /
[debug] Processing by PlatformWeb.PageController.index/2
  Parameters: %{}
  Pipelines: [:browser]
[info] Sent 200 in 67ms
^C
BREAK: (a)bort (c)ontinue (p)roc info (i)nfo (l)oaded
       (v)ersion (k)ill (D)b-tables (d)istribution
^C
$ 
```

## Первый ресурс

Поскольку мы создаем небольшую игровую платформу, есть два основных ресурса, с которых нам лучше начать:

- Игроки
- Игры

Мы собираемся начать с использования так называемого генератора, чтобы быстрее двигаться. Он создаст много файлов, с которыми нужно работать. Затем позже мы узнаем больше про то, как все это работает.

Давайте сгенерируем ресурс для наших игроков с помощью следующей команды:

```shell
$ mix phx.gen.html Accounts Player players username:string score:integer
```

С помощью этой команды мы создаем игроков для нашей игровой платформы. Мы хотим использовать браузер для работы с данными, поэтому мы начинаем с файла [`phx.gen.html`](https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.Html.html), чтобы создать HTML-ресурс.

Поскольку мы создаем учетные записи игроков для разрабатываемого приложения, мы используем `Accounts`, чтобы предоставить _контекст_ для нашего ресурса. Затем мы используем `Player` в качестве имени модуля и `players`, чтобы указать на множественную форму, которая также будет использоваться для создания таблицы базы данных.

Для полей игрока каждый аккаунт игрока будет иметь имя пользователя (`username`, хранится в виде строки) и счет (`score`, хранится как целое число). Со временем мы расширим потенциал наших игроков дополнительными полями, но пока это даст нам хорошую отправную точку для начала создания списка игроков.

Вы увидите, что генератор создает довольно много файлов, и в очередной раз Phoenix дает нам несколько полезных советов по поводу дальнейших действий:

```shell
$ mix phx.gen.html Accounts Player players username:string score:integer
* creating lib/platform_web/controllers/player_controller.ex
* creating lib/platform_web/templates/player/edit.html.eex
* creating lib/platform_web/templates/player/form.html.eex
* creating lib/platform_web/templates/player/index.html.eex
* creating lib/platform_web/templates/player/new.html.eex
* creating lib/platform_web/templates/player/show.html.eex
* creating lib/platform_web/views/player_view.ex
* creating test/platform_web/controllers/player_controller_test.exs
* creating lib/platform/accounts/player.ex
* creating priv/repo/migrations/20170807120444_create_players.exs
* creating lib/platform/accounts/accounts.ex
* injecting lib/platform/accounts/accounts.ex
* creating test/platform/accounts/accounts_test.exs
* injecting test/platform/accounts/accounts_test.exs
```

Добавьте ресурс в область видимости браузера в файл `lib/platform_web/router.ex`:

    resources "/players", PlayerController

Не забудьте обновить репозиторий, запустив миграцию:

    $ mix ecto.migrate

## Маршрутизация

Пока не беспокойтесь о всех этих файлах, но информация ниже важна. Чтобы настроить приложение для работы с нашими новыми учетными записями игроков, нужно сначала добавить их в маршрутизатор, а затем запустить миграцию для обновления базы данных (добавить новую таблицу `players`).

Phoenix облегчает нам задачу с помощью полезных заметок в терминале. Давайте пойдем вперед и повторяем, что написано далее. Откройте файл `lib/platform_web/router.ex` и посмотрите, как он выглядит:

```elixir
defmodule PlatformWeb.Router do
  use PlatformWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_flash
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  pipeline :api do
    plug :accepts, ["json"]
  end

  scope "/", PlatformWeb do
    pipe_through :browser

    get "/", PageController, :index
  end

  # Other scopes may use custom stacks.
  # scope "/api", PlatformWeb do
  #   pipe_through :api
  # end
end
```

Маршрутизатор Phoenix поставляется с двумя отдельными «конвейерами» по умолчанию. Один из них предназначен для HTML (который мы собираемся использовать в данный момент), а другой — для JSON (который мы также будем использовать, но позже). И мы даже можем видеть, что `scope` уже настроена для доступа к HTML через браузер. Вот так мы смогли открыть URL-адрес `http://localhost:4000` и увидеть начальную стартовую страницу. Не волнуйтесь, если это поначалу кажется непонятным. Учтите только одно — сейчас мы остановимся на этом блоке кода:

```elixir
scope "/", PlatformWeb do
  pipe_through :browser

  get "/", PageController, :index
end
```

Далее мы собираемся обновить этот фрагмент, добавив новый ресурс игроков:

```elixir
scope "/", PlatformWeb do
  pipe_through :browser # Use the default browser stack

  get "/", PageController, :index
  resources "/players", PlayerController
end
```

Это означает, что когда мы получим доступ к [`http://localhost:4000/players`](http://localhost:4000/players), мы скоро сможем начать создавать игроков для нашей игровой платформы.

## Запуск миграции

Наше приложение содержит всю информацию, необходимую для отображения созданного нами ресурса игроков, но нам все еще нужно сообщить базе данных про внесенные изменения. Чтобы база данных сохраняла данные наших игроков (с полями `username` и `score`), нужно выполнить миграцию. Вернитесь в терминал и выполните следующую команду:

```shell
$ mix ecto.migrate
```

Это создаст новую таблицу базы данных `players`. Если все идет по плану, то мы должны увидеть следующий вывод:

```shell
$ mix ecto.migrate
Compiling 10 files (.ex)
Generated platform app
08:18:44.181 [info]  == Running Platform.Repo.Migrations.CreatePlayers.change/0 forward
08:18:44.182 [info]  create table players
08:18:44.371 [info]  == Migrated in 0.1s
```

## Создание игроков

Давайте снова запустим сервер и увидим ресурс игрока в действии:

```shell
$ mix phx.server
```

Теперь мы можем перейти по адресу
[http://localhost:4000/players](http://localhost:4000/players) и увидим
следующее:

![Пустой список игроков на индексной странице игрока](images/diving_in/empty_players_list.png)

Прекрасно, теперь мы можем через браузер добавлять игроков на платформу. Нажмите на ссылку **New Player** внизу и попробуйте создать игрока на странице [`http://localhost:4000/players/new`](http://localhost:4000/players/new).

![Страница нового игрока](images/diving_in/new_player.png)

После того, как мы успешно создадим новую учетную запись игрока, мы перейдем на страницу с псевдонимом «show», на которой будут отображены данные по конкретному игроку (обратите внимание, что идентификатор (`id`) игрока также отображается в URL-адресе):

![Страница отображения информации об игроке](images/diving_in/new_player_created.png)

Не стесняйтесь создавать дополнительные учетные записи игроков, поскольку эти данные выводятся на странице игроков:

![Страница со списком игроков с демонстрационными данными](images/diving_in/list_players.png)

## Обновление главной страницы

У нас есть работающий ресурс игроков с индексной страницей всех игроков, страница отображения игрока, страница редактирования для обновления данных по игроку, а ещё возможность удаления игроков. Но когда мы возвращаемся на нашу домашнюю страницу по адресу [`http://localhost:4000`](http://localhost:4000), эти страницы не доступны. Наши пользователи не знают, что им нужно посетить страницу `/players/new` для создания своего аккаунта. Рано или поздно мы захотим, чтобы наши пользователи могли создавать свои учетные записи, при этом не редактируя и не удаляя другие. Для начала давайте выясним, откуда приходит HTML-код для нашей домашней страницы.

Внутри директории `lib/platform_web` есть директория `templates`. Здесь мы храним HTML-код, который показывается в браузере. И вместо обычных файлов с расширением `.html` мы увидим, что файлы имеют расширение `.html.eex`. Это означает, что мы можем писать знакомый нам HTML-код, а также встроить код на Elixir.

Давайте откроем файл `lib/platform_web/templates/page/index.html.eex` и посмотрим его содержимое (обратите внимание, что часть кода HTML была обрезана для удобства чтения):

```embedded_elixir
<section class="phx-hero">
  <h1><%= gettext "Welcome to %{name}!", name: "Phoenix" %></h1>
  <p>A productive web framework that<br/>does not compromise speed and maintainability.</p>
</section>

<section class="row">
  <article class="column">
    <h2>Resources</h2>
    <!-- ... -->
  </article>
  <article class="column">
    <h2>Help</h2>
    <!-- ... -->
  </article>
</section>
```

Это должно выглядеть знакомо, поскольку в основном код состоит из обычного HTML-кода. Это HTML-код, который мы видим при загрузке [`http://localhost:4000`](http://localhost:4000). Давайте удалим этот код и создадим пару простых ссылок на страницы игроков. Сначала удалите _весь_ существующий код в файле `lib/platform_web/templates/page/index.html.eex`. Затем замените его на следующий:

```html
<div class="container">
  <a class="button" href="/players/new">Create Player Account</a>
  <a class="button" href="/players">List All Players</a>
</div>
```

Сохраните файл и вернитесь в браузер, чтобы увидеть изменения (убедитесь, что веб-сервер Phoenix все еще запущен, либо перезапустите сервер с помощью `mix phx.server`) по адресу [`http://localhost:4000`](http://localhost:4000):

![Главная страница со ссылкой на списком игроком](images/diving_in/updated_home_page.png)

Phoenix поставляется с функцией **Live Reload**, которая автоматически обновляет приложение в браузере. Если сервер Phoenix все еще работал, то главная страница будет автоматически перезагружена и теперь должна отображать созданные только что кнопки. Посмотрите на результат, и с помощью них пользователи смогут свободно переходить на страницу определенного игрока в приложении.

## Написание Elixir-кода

Наконец, давайте получим небольшой опыт написания кода на Elixir в шаблонах, использовав встроенный код Elixir для вывода кнопок вместо простого HTML. Страница будет выглядеть точно так же, но это даст нам возможность использовать возможность Phoenix вместо написания HTML.

Phoenix предоставляет функцию [link](https://hexdocs.pm/phoenix_html/Phoenix.HTML.Link.html#link/2), которую мы можем использовать; на странице документации к этой функции можно увидеть несколько примеров использования.

Поскольку мы работаем с файлом расширения `.eex`, это означает, что мы можем встроить код Elixir, окружив его тегами `<%= ... %>`. Код Elixir, который мы поместим в эти теги, будет выполнен, а затем выведен на страницу.

При работе с Elixir полезной техникой отладки является использование функции [`IO.inspect`](https://hexdocs.pm/elixir/IO.html#inspect/2), чтобы отобразить результаты. В этом примере мы используем модуль `IO` с функцией `inspect` и передадим ей строку `"Hello World!"`:

```embedded_elixir
<div class="container">
  <a class="button" href="/players/new">Create Player Account</a>
  <a class="button" href="/players">List All Players</a>

  <%= IO.inspect("Hello World!") %>
</div>
```

Давайте посмотрим на результат в браузере:

![Встроенный код Elixir](images/diving_in/embedded_elixir.png)

Мы можем сделать что-то подобное, чтобы вставить ссылку на нашу страницу. Нам не нужно явно указывать модуль (`Phoenix.HTML.Link`), потому что у нас уже есть доступ к некоторым полезным функциям Phoenix в данном контексте. Мы можем воссоздать наши существующие HTML-ссылки с помощью следующего кода, передав текст ссылки, адрес и CSS-класс кнопки, чтобы он выглядел хорошо (Phoenix поставляется с небольшим предустановленным CSS-фреймворком):

```embedded_elixir
<div class="container">
  <%= link("Create Player Account", to: "/players/new", class: "button") %>
  <%= link("List All Players", to: "/players", class: "button") %>
</div>
```

Теперь мы можем убедиться, что наши ссылки по-прежнему работают так же, как и раньше:

![Ссылка по страницу игроков с использованием встроенного Elixir-кода](images/diving_in/updated_home_page.png)

## Резюме

В этой главе нам удалось охватить много вопросов. Мы смогли создать фундамент для нашего приложения с помощью бэкенда на Phoenix. Мы использовали генераторы Phoenix для создания ресурса игроков, начали понимать, как выглядит структура директорий Phoenix, а также начали редактировать файлы. Кроме этого, немного узнали о маршрутизации и работе с базой данных.

Мы получили вводный взгляд на то, как создать полноценную веб-платформу с использованием Elixir и Phoenix, и даже создали пару записей об игроках, которые мы можем использовать, когда продолжим разработку. Но мы быстро прошли через все эти шаги, и у нас пока нет четкого понимания того, как все кусочки складываются в единую мозаику. В следующей главе мы углубимся в некоторые основы Elixir. И вместо того, чтобы использовать генераторы, как мы делали в этой главе, вручную создадим функциональность нашего приложения, чтобы продолжать увеличивать опыт.
